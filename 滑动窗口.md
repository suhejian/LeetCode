## 滑动窗口

滑动窗口其实就是**队列**，一开始先初始化窗口的左右端点，然后*移动右端点*至窗口符合要求，在移动过程中，达到满足条件以后再移动可能就不会满足条件，此时需要*移动左端点*。如此反复。
一般题目中出现**连续子串**时，都可以考虑滑动窗口的思想解决问题。

---

相关题目：

- [x] 3.无重复字符的最长子串
- [x] 30.串联所有单词的子串
- [x] 76.最小覆盖子串
- [x] 209.长度最小的子数组
- [x] 713.乘积小于K的子数组
- [ ] 239.滑动窗口最大值
- [ ] 567.字符串的排列
- [ ] 632.最小区间
- [ ] 727.最小窗口子序列

---

### 3.无重复字符的最长子串

> 给定一个字符串`s`，找出其中不含有重复字符的**最长子串**的长度

分析：题目中提到**最长子串**，即*最长连续子串*，可以考虑滑动窗口的思想。

那么可以遵照一般规律，一开始先初始化窗口的左右端点，然后*移动右端点*至窗口符合要求，在移动过程中，达到满足条件以后再移动可能就不会满足条件，此时需要*移动左端点*。如此反复。唯一需要注意的就是，该题中的`符合要求`是`无重复字符`。

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        if not s:
            return 0

        start, end = 0, 0
        res = 0
        window = []
        for end in range(len(s)):
            while s[end] in window:
                window.pop(0)

            window.append(s[end])
            res = max(res, len(window))

        return res
```

### 30.串联所有单词的子串

> 给定一个字符串`s`和一些**长度相同**的单词`words`，找出`s`中恰好可以由`words`中所有单词串联形成的子串的起始位置。

分析：要找到满足条件的子串的起始位置，其实就是看一个连续子串是否满足条件——>滑动窗口。当然，这一题也可以理解为双指针的思想。

```python
class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        start = 0
        window = []
        res = []
        for end in range(len(words) * len(words[0]), len(s) + 1):
            window = s[start: end]
            elements = [window[i: i + len(words[0])] for i in range(0, len(window), len(words[0]))]
            if sorted(elements) == sorted(words):
                # 符合要求
                res.append(start)
            start += 1
        return res
```

### 76.最小覆盖子串

> 给定一个字符串`s`和一个字符串`t`，返回`s`中涵盖`t`中所有字符的最小子串。如果`s`中不存在涵盖`t`所有字符的子串，则返回空字符串`""`。

分析：如何判定一个子串是否涵盖`t`的所有字符？可以考虑用`hashmap`存储需要的相应字符数量，同时用一个单独的变量表示该子串是否能涵盖`t`的所有字符，以避免每次都遍历`hashmap`。另外，该题中需要求的是**最小子串**，此时可以考虑**滑动窗口**的思想。

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        from collections import defaultdict
        need = defaultdict(int)
        for c in t:
            need[c] += 1

        i = 0
        needCnt = len(t)
        ans = (0, float('inf'))
        for j, c in enumerate(s):
            # 如果是t中的字符
            if need[c] > 0:
                needCnt -= 1
            need[c] -= 1

            if needCnt == 0:
                # 此窗口已满足要求，可以考虑移动左端点
                while True:
                    if need[s[i]] == 0:
                        # 左端点是t中需要的字符, 不能再删除了
                        break
                    # 可以删除多余的左端点元素
                    need[s[i]] += 1
                    i += 1

                # 更新结果
                if j - i < ans[1] - ans[0]:
                    ans = (i, j)

                # 移动i, 重新计算
                need[s[i]] += 1
                needCnt += 1
                i += 1
        return "" if ans[1] > len(s) else s[ans[0]: ans[1] + 1]
```

### 209.长度最小的子数组

> 给定一个含有`n`个正整数的数组和一个正整数`target`，找出该数组中满足其和$\geq$`target`的长度最小的**连续子数组**，并返回其长度。如果不存在符合条件的子数组，返回`0`。

分析：看到题目中要求**长度最小**的**连续子数组**，就可以考虑**滑动窗口**。

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        if not nums:
            return 0
        slow, fast, total = 0, 0, 0
        min_length = len(nums) + 1
        for fast in range(len(nums)):
            total += nums[fast]
            while total >= target:
                min_length = min(min_length, fast - slow + 1)
                total -= nums[slow]
                slow += 1
        return 0 if min_length == len(nums) + 1 else min_length
```

### 713.乘积小于K的子数组

这一题和上一题非常相似。

```python
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        # 滑动窗口, 防止重复计算需要以右边界为准计算
        # ABCX -> X, CX, BCX, ABCX
        start = 0   # 滑动窗口左侧
        res = 0 # 最终结果
        total = 1 # 计算当前积
        for end in range(len(nums)):
            total *= nums[end]
            while start <= end and total >= k:
               total = total // nums[start]
               start += 1
            res += (end - start + 1)
        return res
```
